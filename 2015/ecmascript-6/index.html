<!DOCTYPE html><html><head><meta charSet="utf-8" class="next-head next-head"/><title class="next-head">ECMAScript 6</title><meta name="viewport" content="width=device-width, initial-scale=1" class="jsx-3820774761 next-head"/><link href="/atom" type="application/atom+xml" rel="alternate" title="Guillermo Rauch" class="jsx-3820774761 next-head"/><link rel="preload" href="/blog/_next/dc2e2233-e78a-4275-85a1-fbfe15f0ab24/page/2015/ecmascript-6.js" as="script"/><link rel="preload" href="/blog/_next/dc2e2233-e78a-4275-85a1-fbfe15f0ab24/page/_app.js" as="script"/><link rel="preload" href="/blog/_next/dc2e2233-e78a-4275-85a1-fbfe15f0ab24/page/_error.js" as="script"/><link rel="preload" href="/blog/_next/static/commons/main-9974819317c34756e49c.js" as="script"/><style id="__jsx-2490235587">h1.jsx-2490235587{font:18px Helvetica Neue,Helvetica, Arial,"Lucida Grande",sans-serif;font-weight:500;margin-bottom:10px;}
a.jsx-2490235587{color:#FF001F;-webkit-text-decoration:none;text-decoration:none;}
a.jsx-2490235587:hover{background-color:#FF001F;color:#fff;}</style><style id="__jsx-2986921676">div.jsx-2986921676{margin-bottom:20px;color:#777;}
.highlight.jsx-2986921676{-webkit-animation-name:highlight-jsx-2986921676;animation-name:highlight-jsx-2986921676;-webkit-animation-duration:1s;animation-duration:1s;-webkit-animation-fill-mode:forwards;animation-fill-mode:forwards;}
@-webkit-keyframes highlight-jsx-2986921676{from{background-color:yellow;}to{background-color:#fff;}}
@keyframes highlight-jsx-2986921676{from{background-color:yellow;}to{background-color:#fff;}}</style><style id="__jsx-847609887">blockquote.jsx-847609887{margin:30px 0;color:#9B9B9B;font-style:oblique;font-size:12px;}
p.jsx-847609887{line-height:24px;}</style><style id="__jsx-65788776">a.jsx-65788776{top:-5px;font-size:10px;position:relative;-webkit-text-decoration:none;text-decoration:none;}</style><style id="__jsx-4038270940">p.jsx-4038270940{font-size:14px;line-height:24px;margin-bottom:20px;}</style><style id="__jsx-3001872643">div.jsx-3001872643{margin:25px 0;font-family:Helvetica Neue,Helvetica,Arial, "Lucida Grande",sans-serif;}
span.jsx-3001872643{position:absolute;margin-left:-15px;width:15px;}
a.jsx-3001872643{visibility:hidden;}
div.jsx-3001872643:hover a.jsx-3001872643,span.jsx-3001872643:hover a.jsx-3001872643{visibility:visible;}</style><style id="__jsx-815773015">pre.jsx-815773015{line-height:20px;margin-bottom:20px;font-size:12px;}
code.jsx-815773015{color:#999;}</style><style id="__jsx-4056748551">code.jsx-4056748551{color:#666;font-family:monospace;}</style><style id="__jsx-498768774">a.jsx-498768774{-webkit-text-decoration:none;text-decoration:none;}</style><style id="__jsx-1193587053">div.jsx-1193587053::before{width:200px;content:' ';margin:auto;border-top:1px solid #ccc;padding-top:40px;display:block;margin-top:40px;}</style><style id="__jsx-3772128426">article.jsx-1962989807{max-width:650px;margin:auto;font-size:14px;}</style><style id="__jsx-2158040620">body{width:100%;overflow-x:hidden;}</style><style id="__jsx-3820774761">*{margin:0;box-sizing:border-box;}
body{font:13px Menlo,Monaco,Lucida Console,Liberation Mono,DejaVu Sans Mono,Bitstream Vera Sans Mono,Courier New,monospace,serif;}
a{color:#22BAD9;-webkit-tap-highlight-color:rgba(0,0,0,0);}
a:hover{color:#fff;background:#22BAD9;-webkit-text-decoration:none;text-decoration:none;}
#nprogress{pointer-events:none;}
#nprogress .bar{background:#22BAD9;position:fixed;z-index:1031;top:0;left:0;width:100%;height:2px;}
#nprogress .peg{display:block;position:absolute;right:0px;width:100px;height:100%;box-shadow:0 0 10px #22BAD9,0 0 5px #22BAD9;opacity:1.0;-webkit-transform:rotate(3deg) translate(0px,-4px);-ms-transform:rotate(3deg) translate(0px,-4px);transform:rotate(3deg) translate(0px,-4px);}</style><style id="__jsx-942610349">.main.jsx-942610349{padding:25px 50px;}
.logo.jsx-942610349{padding-bottom:50px;}
a.jsx-942610349{-webkit-text-decoration:none;text-decoration:none;}
@media (max-width:500px){.main.jsx-942610349{padding:25px 15px;}.logo.jsx-942610349{padding-bottom:20px;}}</style></head><body><div id="__next"><div class="jsx-942610349 main"><div class="jsx-942610349 logo"><a class="jsx-942610349" href="/">rauchg.com</a> <!-- -->(<a href="https://github.com/rauchg/blog" target="_blank" class="jsx-942610349">src</a>)</div><article class="jsx-1962989807"><h1 class="jsx-2490235587"><a href="#" class="jsx-2490235587">ECMAScript 6</a></h1><div class="jsx-2986921676">February 22, 2015<!-- --> – <!-- --> <span class="jsx-2986921676 ">108,603<!-- --> views</span></div><blockquote class="jsx-847609887"><p class="jsx-847609887">The limits of my language mean the limits of my world.<br class="jsx-847609887"/>– Ludwig Wittgenstein</p></blockquote><p class="jsx-4038270940">For the past few months I’ve been exclusively writing ECMAScript 6 code by taking advantage of transpilation<a href="#f1" id="s1" class="jsx-65788776">[<!-- -->1<!-- -->]</a> to a currently supported version of JavaScript.</p><p class="jsx-4038270940">ECMAScript 6, henceforth ES6 and formerly ES.next, is the latest version of the specification. As of August 2014 no new features are being discussed, but details and edge cases are still being sorted out. It’s expected to be completed and published mid-2015.</p><p class="jsx-4038270940">Adopting ES6 has simultaneously resulted in increased productivity (by making my code more succinct) and eliminated entire classes of bugs by addressing common JavaScript gotchas.</p><p class="jsx-4038270940">More importantly, however, it’s reaffirmed my belief in an evolutionary approach towards language and software design as opposed to <a href="http://www.sigcomm.org/sites/default/files/ccr/papers/2008/January/1341431-1341436.pdf" target="_blank">clean-slate recreation</a></p><p class="jsx-4038270940">This should be fairly obvious to you if you’ve been using CoffeeScript, which set out to focus on the good parts of JS and hide the broken ones. ES6 has been able to adopt a lot of CoffeeScript’s great innovations in a non-disruptive way, to such an extent that some have even questioned its <a href="https://github.com/jashkenas/coffeescript/issues/3859" target="_blank">role moving forward</a>.</p><blockquote class="jsx-847609887"><p class="jsx-847609887">For all intents and purposes, JavaScript has merged CoffeeScript into master.  I call that a victory for making things and trying them out.<br class="jsx-847609887"/>– [object Object]</p></blockquote><p class="jsx-4038270940">Instead of making a thorough review of <a href="https://github.com/lukehoban/es6features" target="_blank">all the new features</a>, I’ll point out the most interesting ones. To incentivize developers to upgrade, new languages or frameworks need to (1) feature a compelling compatibility story and (2) give you a <a href="http://teddziuba.tumblr.com/post/26426290981/python-3s-marketing-problem" target="_blank">big enough carrot</a>.</p><div class="jsx-3001872643"><h2 style="font-weight:500;font-size:16px"><span class="jsx-3001872643"><a href="#the-module-syntax" id="the-module-syntax" class="jsx-3001872643">#</a></span>The module syntax</h2></div><p class="jsx-4038270940">ES6 introduces <b>syntax</b> for defining modules and declaring dependencies. I emphasize the word syntax because ES6 is not concerned with the actual implementation details of how modules are fetched or loaded.</p><p class="jsx-4038270940">This further strengthens the <b>interoperability</b> between the different contexts in which JavaScript can be executed.</p><p class="jsx-4038270940">Up to now, no guidelines existed for how to actually do this. A common approach is to introduce a function declaration:</p><p class="jsx-4038270940">Consider as an example the simple task of writing a reusable implementation of <a target="_blank" href="http://en.wikipedia.org/wiki/Cyclic_redundancy_check">CRC32</a> in JavaScript.</p><p class="jsx-4038270940">Up to now, no guidelines existed for how to actually do this. A common approach is to introduce a function declaration:</p><pre class="jsx-815773015"><code class="jsx-815773015">function crc32 () {
  // …
}</code></pre><p class="jsx-4038270940">With the caveat, of course, that it introduces a single fixed global name that other parts of the code will have to refer to. And from the perspective of the code that uses that <code class="jsx-4056748551">crc32</code> function, there’s no way to declare the dependency. One just has to assume the function will exist prior to the code’s interpretation.</p><p class="jsx-4038270940">With this situation in mind, Node.JS led the way with the introduction of the <code class="jsx-4056748551">require</code> runtime function and the <code class="jsx-4056748551">module.exports</code> and <code class="jsx-4056748551">exports</code> objects. Despite succeeding in creating a thriving ecosystem of modules around it, the interoperability possibilities were still somewhat limited.</p><p class="jsx-4038270940">A common scenario to illustrate this is the generation of browser bundles of modules, with tools like <a href="http://browserify.org/" target="_blank">browserify</a> or <a href="https://github.com/webpack/webpack" target="_blank">webpack</a>. These can only be conceived because they treat <code class="jsx-4056748551">require()</code> as syntax, effectively ridding it of its inherent dynamism.</p><p class="jsx-4038270940">If you’re trying to transport code to the browser, the following is not subject to static analysis and therefore breaks:</p><pre class="jsx-815773015"><code class="jsx-815773015">require(woot() + ‘_module.js’)</code></pre><p class="jsx-4038270940">In other words, the packer’s algorithm can’t possibly know what <code class="jsx-4056748551">woot()</code> means ahead of time.</p><p class="jsx-4038270940">ES6 has introduced the right set of restrictions while accomodating for most existing use cases, drawing inspiration from most of the informally-specified ad-hoc module systems out there, like jQuery’s <code class="jsx-4056748551">$</code>.</p><p class="jsx-4038270940">The syntax does take some getting used to. The most common pattern for dependency definitions is surprisingly impractical.</p><p class="jsx-4038270940">The following code:</p><pre class="jsx-815773015"><code class="jsx-815773015">import crc32 from ‘crc32’</code></pre><p class="jsx-4038270940">works for</p><pre class="jsx-815773015"><code class="jsx-815773015">export default function crc32(){}</code></pre><p class="jsx-4038270940">but not for</p><pre class="jsx-815773015"><code class="jsx-815773015">export function crc32()</code></pre><p class="jsx-4038270940">the latter is considered a <em>named export</em> and requires the <code class="jsx-4056748551">{ }</code> syntax in the import statement:</p><pre class="jsx-815773015"><code class="jsx-815773015">import { crc32 } from ‘crc32’</code></pre><p class="jsx-4038270940">In other words, the simplest (and arguably most desirable) form of module definition requires the extra default keyword. Or in the absence of that, the usage of <code class="jsx-4056748551">{ }</code> when importing.</p><div class="jsx-3001872643"><h2 style="font-weight:500;font-size:16px"><span class="jsx-3001872643"><a href="#destructuring" id="destructuring" class="jsx-3001872643">#</a></span>Destructuring</h2></div><p class="jsx-4038270940">One of the most common patterns that has emerged in modern JavaScript code is the usage of option objects.</p><p class="jsx-4038270940">So common is this practice that newly specified browser APIs, like WHATWG’s <a href="https://fetch.spec.whatwg.org/" target="_blank">fetch</a> (a modern substitute for XMLHttpRequest) follow it:</p><pre class="jsx-815773015"><code class="jsx-815773015">fetch(‘/users’, {
  method: ‘POST’,
  headers: {
    Accept: ‘application/json’,
    ‘Content-Type’: ‘application/json’
  },
  body: JSON.stringify({
    first: ‘Guillermo’,
    last: ‘Rauch’
  })
})</code></pre><p class="jsx-4038270940">The widespread adoption of this pattern has effectively prevented the JavaScript ecosystem from falling into <a href="http://ariya.ofilabs.com/2011/08/hall-of-api-shame-boolean-trap.html" target="_blank">The Boolean Trap</a>.</p><p class="jsx-4038270940">If said API accepted regular parameters as opposed to an options object, calling fetch would be an exercise in argument order memorization and the typing of the <code class="jsx-4056748551">null</code> keyword.</p><pre class="jsx-815773015"><code class="jsx-815773015">// artistic rendition of a nightmare alternative world
fetch(‘/users’, ‘POST’, null, null, {
  Accept: ‘application/json’,
  ‘Content-Type’: ‘application/json’
}, null, JSON.stringify({
  first: ‘Guillermo’,
  last: ‘Rauch’
}))</code></pre><p class="jsx-4038270940">On the implementation side of things, however, things haven’t looked nearly as pretty. Looking at the function’s declaration signature is no longer descriptive of its input’s possibilities:</p><pre class="jsx-815773015"><code class="jsx-815773015">
function fetch(url, opts){
  // …
}</code></pre><p class="jsx-4038270940">Usually followed by the manual assignment of defaults to local variables:</p><pre class="jsx-815773015"><code class="jsx-815773015">opts = opts || {}
var body = opts.body || &#x27;&#x27;
var headers = opts.headers || {}
var method = opts.method || &#x27;GET&#x27;</code></pre><p class="jsx-4038270940">And unfortunately for us, despite being common, the <code class="jsx-4056748551">||</code> practice actually introduces subtle bugs. In this case we’re not admitting that <code class="jsx-4056748551">opts.body</code> could be 0, so robust code would most likely look like:</p><pre class="jsx-815773015"><code class="jsx-815773015">var body = opts.body === undefined ? &#x27;&#x27; : opts.body</code></pre><p class="jsx-4038270940">Thanks to destructured parameters we can at once clearly define the parameters, properly set defaults and expose them to the local scope:</p><pre class="jsx-815773015"><code class="jsx-815773015">fetch(url, { body=&#x27;&#x27;, method=&#x27;GET&#x27;, headers={} }){
  console.log(method) // no opts. everywhere!
</code></pre><p class="jsx-4038270940">As a matter of fact, defaults can also apply to the entire object parameter as well:</p><pre class="jsx-815773015"><code class="jsx-815773015">fetch(url, { method=&#x27;GET&#x27; } = {}){
  // the second parameter defaults to {}
  // the following will output &quot;GET&quot;:
  console.log(method)
}</code></pre><p class="jsx-4038270940">You can also destructure with the assignment operator as follows:</p><pre class="jsx-815773015"><code class="jsx-815773015">var { method, body } = opts</code></pre><p class="jsx-4038270940">This is reminiscent to me of the expressiveness granted by <code class="jsx-4056748551">with</code>, without the magic or negative performance implications.</p><div class="jsx-3001872643"><h2 style="font-weight:500;font-size:16px"><span class="jsx-3001872643"><a href="#new-conventions" id="new-conventions" class="jsx-3001872643">#</a></span>New Conventions</h2></div><p class="jsx-4038270940">Some parts of the language have been altogether replaced with better alternatives that’ll quickly become a new default for how you write JavaScript.</p><p class="jsx-4038270940">I’ll go over some of them.</p><div class="jsx-3001872643"><h3 style="font-weight:500;font-size:14px"><span class="jsx-3001872643"><a href="#let-and-const-over-var" id="let-and-const-over-var" class="jsx-3001872643">#</a></span>let/const over var</h3></div><p class="jsx-4038270940">Instead of writing <code class="jsx-4056748551">var x = y</code> you’ll most likely be writing <code class="jsx-4056748551">let x = y</code>. let scopes your variable definition to the block it’s defined in:</p><pre class="jsx-815773015"><code class="jsx-815773015">if (foo) {
  let x = 5
  setTimeout(function(){ 
    // x is `5` here   
  }, 500)
}
// x is `undefined` here</code></pre><p class="jsx-4038270940">This is especially useful for <code class="jsx-4056748551">for</code> or <code class="jsx-4056748551">while</code> loops:</p><pre class="jsx-815773015"><code class="jsx-815773015">for (let i = 0; i &lt; 10; i++) {}
// `i` doesn&#x27;t exist here.</code></pre><p class="jsx-4038270940">When you want to ensure <a href="https://mathiasbynens.be/notes/es6-const" target="_blank">binding immutability</a> with the same semantics as <code class="jsx-4056748551">let</code>, use <code class="jsx-4056748551">const</code> instead.</p><div class="jsx-3001872643"><h3 style="font-weight:500;font-size:14px"><span class="jsx-3001872643"><a href="#template-strings" id="template-strings" class="jsx-3001872643">#</a></span>template strings over concatenation</h3></div><p class="jsx-4038270940">With the lack of <code class="jsx-4056748551">sprintf</code> or similar utilities in the standard JavaScript library, composing strings has always been more painful than it should.</p><p class="jsx-4038270940">Template strings make the embedding of expressions trivial, as well as support for multiple lines. Simply replace <code class="jsx-4056748551">‘</code> with <code class="jsx-4056748551">`</code>.</p><pre class="jsx-815773015"><code class="jsx-815773015">let str = `
  Hello ${first}. 
  We are in the year ${new Date().getFullYear()}
`</code></pre><div class="jsx-3001872643"><h3 style="font-weight:500;font-size:14px"><span class="jsx-3001872643"><a href="#class-over-prototypes" id="class-over-prototypes" class="jsx-3001872643">#</a></span>class over prototypes</h3></div><p class="jsx-4038270940">Defining a class was cumbersome and required a deep understanding of the language internals. Even though it’s still obviously useful to grasp the inner-workings, the barrier to entry to newcomers was unnecessarily high.</p><p class="jsx-4038270940"><code class="jsx-4056748551">class</code> offers syntax sugar for defining a constructor <code class="jsx-4056748551">function</code>, the methods within <code class="jsx-4056748551">prototype</code> and getters / setters. It also provides prototypical inheritance with syntax alone (no utilities or 3rd party modules).</p><pre class="jsx-815773015"><code class="jsx-815773015">class A extends B {
  constructor(){}
  method(){}
  get prop(){}
  set prop(){}
}</code></pre><p class="jsx-4038270940">I initially was surprised to learn classes are not hoisted (explanation <a href="https://esdiscuss.org/history/2014-06-05T15%3A54%3A16.000Z-rossberg.google.com?path=%2Ftopic%2Fin-es6-strict-mode-do-function-declarations-within-a-block-hoist" target="_blank">here</a>). You should therefore think of them translating roughly to <code class="jsx-4056748551">var A = function(){}</code> as opposed to <code class="jsx-4056748551">function A(){}</code>.</p><div class="jsx-3001872643"><h3 style="font-weight:500;font-size:14px"><span class="jsx-3001872643"><a href="#fat-arrow-over-function" id="fat-arrow-over-function" class="jsx-3001872643">#</a></span>()=&gt; over function</h3></div><p class="jsx-4038270940">Not only is <code class="jsx-4056748551">(x, y) =&gt; {}</code> shorter to write than <code class="jsx-4056748551">function (x,y) {}</code>, but the behavior of this within the function body will most likely refer to what you want.</p><p class="jsx-4038270940">The so-called “fat arrow” functions are <em>lexically bound</em>. Consider the example of a method within a class that launches two timers:</p><pre class="jsx-815773015"><code class="jsx-815773015">class Person {
  constructor(name){
    this.name = name
  }

  timers(){
    setTimeout(function(){
      console.log(this.name)
    }, 100)

    setTimeout(() =&gt; {
      console.log(this.name)
    }, 100)
  }
}</code></pre><p class="jsx-4038270940">To the dismay of newcomers to the language, the first timer (using <code class="jsx-4056748551">function</code>) will log <code class="jsx-4056748551">&quot;undefined&quot;</code>. The second one will now correctly log name.</p><div class="jsx-3001872643"><h2 style="font-weight:500;font-size:16px"><span class="jsx-3001872643"><a href="#async-io" id="async-io" class="jsx-3001872643">#</a></span>First-class support for async I/O</h2></div><p class="jsx-4038270940">Asynchronous code execution has been around for almost the entire history of the language. <code class="jsx-4056748551">setTimeout</code>, after all, was introduced around the time JavaScript 1.0 came out.</p><p class="jsx-4038270940">But arguably, the language didn’t <em>really support</em> it. The return value of function calls that scheduled “future work” is normally <code class="jsx-4056748551">undefined</code>, or in the case of <code class="jsx-4056748551">setTimeout</code> a <code class="jsx-4056748551">Number</code>.</p><p class="jsx-4038270940">The introduction of <code class="jsx-4056748551">Promise</code> addresses this, and by doing so fills a very large hole of interoperability and <a href="https://blog.jcoglan.com/2011/03/11/promises-are-the-monad-of-asynchronous-programming/" target="_blank">composability</a>.</p><p class="jsx-4038270940">On one hand, APIs you’ll encounter become wholly more predictable. As a test of this, consider the new <code class="jsx-4056748551">fetch</code> API. How does it work beyond the signature we described? You guessed right. It returns a <code class="jsx-4056748551">Promise</code>.</p><p class="jsx-4038270940">If you’ve used Node.JS in the past, you know that there’s an informal contract that callbacks will follow the signature:</p><pre class="jsx-815773015"><code class="jsx-815773015">function (err, result){}</code></pre><p class="jsx-4038270940">Also informally specified is the idea that callbacks will fire <em>only once</em>. And that <code class="jsx-4056748551">null</code> will be the value in the absence of an error (and not <code class="jsx-4056748551">undefined</code> or <code class="jsx-4056748551">false</code>). Except, this might not always <a href="https://medium.com/code-adventures/farewell-node-js-4ba9e7f3e52b#7cda" target="_blank">be the case</a>.</p><div class="jsx-3001872643"><h2 style="font-weight:500;font-size:16px"><span class="jsx-3001872643"><a href="#towards-the-future" id="towards-the-future" class="jsx-3001872643">#</a></span>Towards the future</h2></div><p class="jsx-4038270940">ES6 is gaining a lot of momentum in the ecosystem. <a href="https://twitter.com/addyosmani/status/541978036904554496" target="_blank">Chrome</a> and <!-- --> <a href="https://iojs.org/en/es6.html" target="_blank">io.js</a> have already incorporated some of its features. A lot has already been written about it.</p><p class="jsx-4038270940">But what’s worth pointing out is that this momentum has been largely enabled by <em>transpilation</em> rather than actual support. <a href="http://babeljs.io/" target="_blank">Great tools</a> have emerged to enable transpiling and polyfilling, and browsers have over time added proper debugging and error reporting support for them (through source maps).</p><p class="jsx-4038270940">The evolution of the language and its proposed features are outpacing implementation. As mentioned above, <code class="jsx-4056748551">Promise</code> is genuinely exciting as a building block alone, but consider the benefits of solving <a href="http://tirania.org/blog/archive/2013/Aug-15.html" target="_blank">the callback problem</a> once and for all.</p><p class="jsx-4038270940"><b>ES7</b> is poised to do this by introducing the possibility of <code class="jsx-4056748551">await</code>-ing a promise:</p><pre class="jsx-815773015"><code class="jsx-815773015">async function uploadAvatar(){
  let user = await getUser()
  user.avatar = await getAvatar()
  return await user.save()
}</code></pre><p class="jsx-4038270940">Even though the spec is in its <a href="https://esdiscuss.org/notes/2014-01-30#async-await" target="_blank">early discussions</a>, the same tool that compiles ES6 to ES5 already <a href="http://babeljs.io/docs/usage/transformers/#async-to-generator" target="_blank">enables it</a>.</p><p class="jsx-4038270940">There’s still substantial work left to do to make sure the process of adopting new language syntax and APIs becomes even more friction-less to those getting started.</p><p class="jsx-4038270940">But one thing is for certain: we must embrace the moving target.</p><div class="jsx-1193587053"><p class="jsx-4038270940">1<!-- -->.<!-- --> <a href="#s1" id="f1" class="jsx-498768774">^</a> <!-- -->I use the word “transpilation” throughout the article on the basis of its popularity to refer to JavaScript source-to-source compilation. That aside, the merits of the term are <a href="https://twitter.com/fogus/status/550717447163355136" target="_blank">technically debatable</a>.</p></div></article><div class="jsx-3820774761"></div></div></div><div id="__next-error"></div><script>
          __NEXT_DATA__ = {"props":{"pageProps":{"postId":"2015-ecmascript-6","views":108603}},"page":"/2015/ecmascript-6","pathname":"/2015/ecmascript-6","query":{},"buildId":"dc2e2233-e78a-4275-85a1-fbfe15f0ab24","assetPrefix":"/blog","nextExport":true,"err":null,"chunks":[]}
          module={}
          __NEXT_LOADED_PAGES__ = []
          __NEXT_LOADED_CHUNKS__ = []

          __NEXT_REGISTER_PAGE = function (route, fn) {
            __NEXT_LOADED_PAGES__.push({ route: route, fn: fn })
          }

          __NEXT_REGISTER_CHUNK = function (chunkName, fn) {
            __NEXT_LOADED_CHUNKS__.push({ chunkName: chunkName, fn: fn })
          }

          false
        </script><script async="" id="__NEXT_PAGE__/2015/ecmascript-6" src="/blog/_next/dc2e2233-e78a-4275-85a1-fbfe15f0ab24/page/2015/ecmascript-6.js"></script><script async="" id="__NEXT_PAGE__/_app" src="/blog/_next/dc2e2233-e78a-4275-85a1-fbfe15f0ab24/page/_app.js"></script><script async="" id="__NEXT_PAGE__/_error" src="/blog/_next/dc2e2233-e78a-4275-85a1-fbfe15f0ab24/page/_error.js"></script><script src="/blog/_next/static/commons/main-9974819317c34756e49c.js" async=""></script></body></html>